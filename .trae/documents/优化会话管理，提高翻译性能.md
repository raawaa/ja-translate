# 优化会话管理，提高翻译性能

## 问题分析
当前程序在翻译每个HTML块时都会调用`connection_manager.reset_session()`，导致每次翻译都断开并重新建立iFlow连接。这种设计会产生以下性能问题：
- 每次创建新连接需要建立WebSocket连接，增加延迟
- 频繁的连接重置增加服务器和客户端资源消耗
- 每次连接都需要重新进行身份验证和初始化

用户之前这样设计的原因是为了确保每次翻译都有充足的上下文空间，避免上下文累积导致翻译质量下降。

## 优化方案
1. **移除每次翻译时的会话重置**：不再在`translate_block`函数中调用`reset_session()`
2. **使用持久会话**：使用单个会话翻译所有块，直到遇到上下文限制
3. **处理上下文限制事件**：当收到`StopReason.MAX_TOKENS`时，自动重置会话并**重新翻译当前块**
4. **保留现有错误处理机制**：继续使用现有的连接管理器错误处理逻辑
5. **添加重试机制**：确保每个块最终都能被完整翻译

## 实现步骤
1. 编辑`epub_translator.py`文件
2. 定位到`translate_block`函数（约第1102行）
3. 移除`await connection_manager.reset_session()`调用
4. 修改`translate_block`函数的重试逻辑，使其能处理会话重置后的重新翻译
5. 在`TaskFinishMessage`处理逻辑中，当`stop_reason == StopReason.MAX_TOKENS`时，设置标志位表示需要重新翻译
6. 测试优化后的性能和上下文管理效果

## 预期效果
- 减少连接建立和销毁的开销
- 提高翻译速度，尤其是在翻译大量块时
- 自动处理上下文空间不足的情况，确保每个块都能被完整翻译
- 保持现有错误处理机制的可靠性
- 减少服务器资源消耗

## 核心代码修改
```python
# 在translate_block函数中移除：
# await connection_manager.reset_session()

# 修改重试逻辑，添加会话重置处理
for attempt in range(max_retries):
    try:
        # 发送消息和接收响应的逻辑保持不变
        
        # 在TaskFinishMessage处理中添加：
        if stop_reason == StopReason.MAX_TOKENS:
            print(f"  ⚠️ 警告: 翻译结果可能被截断，因为达到了最大令牌限制")
            # 自动重置会话，确保后续翻译有充足的上下文空间
            print(f"  🔄 自动重置会话，为后续翻译准备充足的上下文空间")
            await connection_manager.reset_session()
            # 标记当前翻译不完整，需要重新尝试
            print(f"  🔄 将重新翻译当前块以确保完整性")
            # 继续重试循环，重新翻译当前块
            continue
        
        # 翻译成功，跳出循环
        break
    except Exception as e:
        # 现有错误处理逻辑保持不变
        
# 确保函数总是返回一个字符串，即使所有重试都失败
return response
```